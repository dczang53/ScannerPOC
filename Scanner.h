#pragma once

#include "FrameGrabber.h"
#include "MotorController.h"

using namespace System;
using namespace System::Drawing;

extern Int32 SQR_SIDE;
extern Int32 D_SIDE;
extern Int32 FRAME_HORIZ;
extern Int32 FRAME_VERT;

namespace SandTimages
{
	ref class frmSandTimages;
}

ref class Scanner
{
public:
	Scanner(SandTimages::frmSandTimages^ form);
	~Scanner();

	//Get/SET SCANNER VARIABLES
	Void lockScan();
	Void unlockScan();
	Void getTopXY(Int32 &x, Int32 &y);
	Void getRightXY(Int32 &x, Int32 &y);
	Void getBottomXY(Int32 &x, Int32 &y);
	Void getLeftXY(Int32 &x, Int32 &y);
	Void getCenterXY(Int32 &x, Int32 &y);
	Boolean setTopXY(Int32 x, Int32 y);
	Boolean setRightXY(Int32 x, Int32 y);
	Boolean setBottomXY(Int32 x, Int32 y);
	Boolean setLeftXY(Int32 x, Int32 y);
	Boolean setCenterXY(Int32 x, Int32 y);
	Void setImageSize(Int32 horiz, Int32 vert);
	Void setTopDiag(Int32 x, Int32 y);
	Void setDT(Int32 dT);
	Void setDS(Int32 dS);
	
	//FRAME OPERATIONS (just load empty images for now)
	Void acquireDisplayFrame();
	Void acquireFrameCenter();
	Bitmap^ getDisplayFrame();
	Bitmap^ getFrameCenter();
	Int32 calcTBoxAverage();				//(previously calcOnePointImage) calc average brightness within dTxdT or dSxdS square centered at (dSide, dSide) (21x21 limit) (ofc dT may be MUCH larger than dSide)
	Int32 calcStBoxAverage();				//(previously calcOnePointImage) same as above, but for all S boxes
	Int32 calcSrBoxAverage();
	Int32 calcSbBoxAverage();
	Int32 calcSlBoxAverage();
	Void writeSquareT();					//draw BLUE square centered at (TRx, TRy) w/ "radius" of (TRd + 1) ON COLORED 640x480 image
	Void writeAllSquareS();					//draw GREEN square centered at (SCx, SCy) w/ "radius" of (SCd + 1) ON COLORED 640x480 image

	//IMAGE OPERATIONS (to be used in the callbacks) (ONLY modify interface to MotorController and/or FrameGrabber changes)
	Void acquireImageTandS();
	Bitmap^ getImageT();
	Bitmap^ getImageS();
	//Bitmap^ getImageCore();

	//PARENT FORM APPLICATION FUNCTION TO REFRESH IMAGES (sets display to corresponding bitmap)
	Void formLoadFrames();
	Void formLoadImages();
	Void formLoadRGB(Int32 R);
	Void formLoadBoxAverages(Int32 St, Int32 Sr, Int32 Sb, Int32 Sl, Int32 T);

	//MOTORCONTROLLER CONTROLS
	Void motorSetReadTimeout(Int32 ms);
	Void motorSetWriteTimeout(Int32 ms);
	Boolean motorIsOpen();
	Boolean motorInitPort(String^ port, String^ baudRate);
	Boolean motorMoveMotor(Int32 motor1, Int32 motor2);
	Void motorAbortMotion();

private:
	//SEMAPHORE FLAG FOR ABORTING OPERATIONS
	Boolean m_semaphore = false;

	//BOX VARIABLES FOR BOXES IN FRAME (NOTE THAT Y-AXIS IS INVERTED)
	Int16 m_XTop = 320, m_YTop = 120;											//(x, y) of Box S_top
	Int16 m_XRight = 480, m_YRight = 240;										//(x, y) of Box S_right
	Int16 m_XBottom = 320, m_YBottom = 360;										//(x, y) of Box S_bottom
	Int16 m_XLeft = 160, m_YLeft = 240;											//(x, y) of Box S_left
	Int16 m_XCenter = 320, m_YCenter = 240;										//(x, y) of Box T
	Int16 m_XTopDiag = 323, m_YTopDiag = 121;									//Calculated from vector, and used for S_Top (not added to Sc like the other 3)
	Int16 m_dS = 1;																//Side Length of S Boxes
	Int16 m_dT = 1;																//Side Length ot T Box

	//INTERMEDIATE AND FINAL IMAGES
	Int32 m_imageHoriz = 4, m_imageVert = 4;									//Image Size (ImageI and ImageJ in original)

	//CURRENT RGB FRAME (GRAB FROM FRAMEGRABBER)
	Bitmap^ m_displayFrame = nullptr;											//Current Frame (with boxes and redscaled)
	Bitmap^ m_frameCenter = nullptr;											//Center Box T of Frame
	Bitmap^ m_imageT = nullptr;													//Final Image for T
	Bitmap^ m_imageS = nullptr;													//Final Image for S
	//Bitmap^ m_imageCore = nullptr;											//Final Image for Core (REMOVED FROM ORIGINAL CODE?)

	//SEPARATE INTERFACES
	SandTimages::frmSandTimages^ m_form;
	MotorController^ m_motorController;
	FrameGrabber^ m_frameGrabber;
};

/*
NAMING CONVENTION NOTATIONS:
-"frame" refers to the actual image taken by the framegrabber
-"image" refers to the image generated by multiple frames from the framegrabber
-"acquire" means perform the necessary actions/calculations to generate one of the private variables of the class
-"get" refers to accessing one of the private variables of the class
-"set" referes to setting on the the private variables of the class
="m_..." refers to a private variable only accessible by the class
*/














	//SCRAPPED
	//array<Byte, 2>^ m_smallArea;												//SQR_SIDExSQR_SIDE (Calculated from Box)

	//void PutTickMarkOnImage(int& EC24Image1);												//not important for now
	//void PutTickMarkOnImage1(int &EC24Image1);											//not important for now
	//void CalcTandS(int RedPic, int x, int y, int dT, int dS, int Ring, int &T, int &S, int &Core);	//OBSOLETE

	//IMAGE OPERATIONS
	/*
	Int32 getScTop();
	Int32 getScRight();
	Int32 getScBottom();
	Int32 getScLeft();
	Int32 getSc();
	Int32 getTr();
	Void resetScTop();
	Void resetScBottom();
	Void resetScLeft();
	Void resetSc();
	Void resetTr();
	Void loadRedImage();
	Void loadGreenImage();
	Void loadBlueImage();
	*/

	//FOR DEBUGGING ORIGINALLY
	/*
	array<Single, 2> ^m_ScTop;		//250x250
	array<Single, 2> ^m_ScRight;	//250x250
	array<Single, 2> ^m_ScBottom;	//250x250
	array<Single, 2> ^m_ScLeft;		//250x250
	array<Single, 2> ^m_Sc;			//250x250
	array<Single, 2> ^m_Tr;			//250x250
	*/

	//COLORED FRAMES (PROBABLY NOT NEEDED)
	//array<Int16, 2> ^m_redFrame;							//FRAME_HORIZxFRAME_VERT
	//array<Int16, 2> ^m_greenFrame;						//FRAME_HORIZxFRAME_VERT
	//array<Int16, 2> ^m_blueFrame;							//FRAME_HORIZxFRAME_VERT

	//Int32 m_ImageI, m_ImageJ;		//OBSOLETE (was used to replace horiz and vert sizes of frame)

	//Int16 m_SJmin, m_SJMAX, m_SImin, m_SIMAX;
	//Int16 m_TJmin, m_TJMAX, m_TImin, m_TIMAX;
	//Int32 m_Time1, m_Time2, m_T1, m_T2;
	//Single m_Tij, m_Sij, m_Coreij;
	//Int16 m_Int1, m_Int2;
	//Byte m_Byte1, m_Byte2;
	//array<Single, 2>^ m_T;		//250x250
	//array<Single, 2>^ m_S;		//250x250
	//String^ m_MatrixStringTr, m_MatrixStringSc;			//Basically for debugging
	//String^ m_MatrixStringScTop, m_MatrixStringScBottom;
	//String^ m_MatrixStringScLeft, m_MatrixStringScRight;
	//array<Int16, 2>^ m_Tint;		//250x250
	//array<Int16, 2>^ m_Sint;		//250x250
	//Int16 m_NumberOfSteps;
	//Bitmap m_redImage;			//Aggregate Image (R) (250x250) (WRITE THIS TO FILE)
	//Bitmap m_greenImage;			//Aggregate Image (B) (250x250) (WRITE THIS TO FILE)
	//Bitmap m_blueImage;			//Aggregate Image (W) (250x250) (WRITE THIS TO FILE)
